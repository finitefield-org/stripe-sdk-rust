use std::env;
use std::fs;
use std::path::PathBuf;

use serde_json::Value;

#[derive(Debug)]
struct OperationRow {
    id: String,
    method: String,
    path: String,
    request_content_type: Option<String>,
}

fn main() {
    let manifest_dir =
        PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("missing CARGO_MANIFEST_DIR"));
    let spec_path = manifest_dir.join("spec/openapi.spec3.json");

    println!("cargo:rerun-if-changed={}", spec_path.display());

    let raw = fs::read_to_string(&spec_path).expect("failed to read spec/openapi.spec3.json");
    let doc: Value = serde_json::from_str(&raw).expect("failed to parse openapi.spec3.json");
    let paths = doc
        .get("paths")
        .and_then(Value::as_object)
        .expect("openapi paths is missing or not an object");

    let mut operations = Vec::new();

    for (path, path_item) in paths {
        let Some(path_item_obj) = path_item.as_object() else {
            continue;
        };

        for (method, operation) in path_item_obj {
            if !is_http_method(method) {
                continue;
            }

            let Some(operation_obj) = operation.as_object() else {
                continue;
            };

            let Some(operation_id) = operation_obj.get("operationId").and_then(Value::as_str)
            else {
                continue;
            };

            operations.push(OperationRow {
                id: operation_id.to_owned(),
                method: method.to_ascii_uppercase(),
                path: path.to_owned(),
                request_content_type: pick_request_content_type(operation_obj.get("requestBody")),
            });
        }
    }

    operations.sort_unstable_by(|a, b| a.id.cmp(&b.id));

    let mut generated = String::new();
    generated.push_str("// This file is @generated by build.rs from spec/openapi.spec3.json.\n");
    generated.push_str(&format!(
        "pub static OPERATIONS: [Operation; {}] = [\n",
        operations.len()
    ));

    for operation in operations {
        let content_type = match operation.request_content_type {
            Some(value) => format!("Some({value:?})"),
            None => "None".to_string(),
        };

        generated.push_str(&format!(
            "    Operation {{ id: {:?}, method: {:?}, path: {:?}, request_content_type: {} }},\n",
            operation.id, operation.method, operation.path, content_type
        ));
    }

    generated.push_str("];\n");

    let out_path =
        PathBuf::from(env::var("OUT_DIR").expect("missing OUT_DIR")).join("operations.rs");
    fs::write(out_path, generated).expect("failed to write generated operations");
}

fn is_http_method(method: &str) -> bool {
    matches!(
        method,
        "get" | "post" | "put" | "patch" | "delete" | "head" | "options" | "trace"
    )
}

fn pick_request_content_type(request_body: Option<&Value>) -> Option<String> {
    let content = request_body
        .and_then(Value::as_object)
        .and_then(|body| body.get("content"))
        .and_then(Value::as_object)?;

    for preferred in [
        "application/x-www-form-urlencoded",
        "application/json",
        "multipart/form-data",
        "application/octet-stream",
    ] {
        if content.contains_key(preferred) {
            return Some(preferred.to_string());
        }
    }

    let mut keys: Vec<&str> = content.keys().map(String::as_str).collect();
    keys.sort_unstable();
    keys.first().map(|value| (*value).to_string())
}
